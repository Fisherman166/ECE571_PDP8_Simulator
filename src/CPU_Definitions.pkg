// CPU_Definitions.pkg
// Jonathan Waldrip

`ifndef CPU_DEF_PKG
`define CPU_DEF_PKG

package CPU_Definitions;

     // Registers
     typedef struct packed {
          logic [11:0] ac;         // accumulator
          logic        lk;         // link bit                   
          logic [11:0] ir;         // instruction register
          logic [11:0] mq;         // mq register }
          logic [11:0] pc;         // program counter
          logic [11:0] mb;         // register to store values from memory 
          logic [11:0] ea;         // effective address register
     } PDP8_Registers_t;
     
     // AC control signal
     typedef enum logic [3:0] {
          AC_SWREG = 0,            // load switch register 
          AC_AND      ,            // AND instruction
          AC_TAD      ,            // TAD instruction
          AC_CLEAR    ,            // Clear 
          AC_MICRO    ,            // Group 1 Microcoded Instruction
          AC_OR_SR    ,            // OR switch register into AC
          AC_OR_MQ    ,            // OR MQ into AC
          AC_OR_DI    ,            // OR datain from IOT with AC 
          AC_LD_MQ    ,            // Load MQ register (for swap) 
          AC_MUL      ,            // Result from EAE for multiply 
          AC_DVI      ,            // Result from EAE for divide
          AC_NC                    // No change
                              } AC_ctrl_t;
     
     // Link control signal
     typedef enum logic [2:0] {
          LK_TAD   = 0,            // TAD instruction
          LK_MICRO    ,            // Group 1 Microcoded Instruction
          LK_MUL      ,            // Result from EAE for multiply 
          LK_DVI      ,            // Result from EAE for divide
          LK_NC                    // No change
                              } LK_ctrl_t;
     
     // MQ control signal
     typedef enum logic [1:0] {
          MQ_AC    = 0,            // for MQ/AC swap operation
          MQ_MUL      ,            // for multiplication
          MQ_DVI      ,            // for division
          MQ_NC                    // No change
                              } MQ_ctrl_t;
     
     // PC control signal
     typedef enum logic [2:0] {
          PC_P1   = 0,             // Normal PC increment
          PC_P2      ,             // Skip
          PC_SR      ,             // Load from front panel
          PC_JMP     ,             // Load from effective address 
          PC_NC                    // No change
                              } PC_ctrl_t;
     
     // IR control signal
     typedef enum logic [1:0] {
          IR_LD   = 0,             // Load instruction from memory
          IR_MEM_P1  ,             // for auto increment
          IR_NC                    // No change
                              } IR_ctrl_t;
     
     // MB control signal
     typedef enum logic       {
          MB_ISZ = 0,              // for ISZ instruction and auto increment
          MB_RD                    // Store memory read
                              } MB_ctrl_t;
     
     // EA control signal
     typedef enum logic [2:0] {
          EA_PGE = 0,            
          EA_SMP    ,            
          EA_IND    ,            
          EA_INC    ,            
          EA_NC                  
                              } EA_ctrl_t;  
                              
     // Memory write data control signal
     typedef enum logic [2:0] {
          WD_MB = 0,               // Contents of memory buffer
          WD_AC    ,               // Contents of accumulator
          WD_EA    ,               // Contents of effective address register
          WD_PCP1  ,               // Program counter plus 1     
          WD_NC                    // No change
                              } WD_ctrl_t;                          
     
     // Memory address control signal
     typedef enum logic [2:0] {
          AD_PC = 0,               // Program counter
          AD_PCP1  ,               // Program counter plus 1
          AD_EA    ,               // Contents of effective address register
          AD_SR    ,               // Switch register from front panel     
          AD_NC                    // No change
                              } AD_ctrl_t;  
                              
     // display out control signal
     typedef enum logic [2:0] {
          DO_PC = 0,               // Display program counter
          DO_MQ    ,               // Display MQ register
          DO_MB    ,               // Display memory location contents
          DO_AC    ,               // Display accumulator
          DO_NC                    // No change
                              } DO_ctrl_t; 
                              
     // dataout control signal
     typedef enum logic       {
          DT_AC = 0,               // Output lower 8 bits of AC
          DT_NC                    // No change
                              } DT_ctrl_t;

     // states for controller
     typedef enum logic [5:0] {
          IDLE    ,      // Idle State                           
          SR_CHG_1,      // Switch register change while not running
          SR_CHG_2,      
          FETCH_1 ,      // Fetch instruction from memory
          FETCH_2 , 
          FETCH_3 ,                      
          LD_PC_1 ,      // Manual load program counter from switch register                            
          LD_AC_1 ,      // Manual load accumulator from switch register                      
          DEP_1   ,      // Manual deposit to memory               
          DEP_2   ,                         
          CAL_EA_1,      // Effective address calculation                 
          EA_IND_1, 
          EA_IND_2, 
          EA_AUT_1, 
          EA_AUT_2, 
          EA_AUT_3, 
          EA_AUT_4, 
          EA_AUT_5, 
          EA_AUT_6, 
          DECODE  ,      // Decode instruction
          AND_1   ,      // AND Instruction  
          AND_2   , 
          TAD_1   ,      // TAD Instruction
          TAD_2   , 
          ISZ_1   ,      // ISZ Instruction
          ISZ_2   ,
          ISZ_3   ,
          ISZ_4   ,
          ISZ_5   ,
          DCA_1   ,      // DCA Instruction     
          DCA_2   ,
          DCA_3   ,
          JMS_1   ,      // JMS Instruction    
          JMS_2   ,    
          JMS_3   ,
          JMP_1   ,
          IOT_1   ,      // IOT Instruction       
          IOT_2   ,
          IOT_3   ,   
          IOT_4   ,
          IOT_5   ,
          IOT_6   ,
          MIC_1   ,      // Microcoded instructions    
          MIC_2   ,   
          MIC_3   ,
          MIC_4   ,
          MIC_5   ,  
          MIC_6   ,
          MIC_7   , 
          MIC_8   ,
          MIC_9    
                              } Controller_states_t;
                              

endpackage : CPU_Definitions

import CPU_Definitions::*;

interface front_panel_pins;
     logic [11:0] swreg  ;    // Switch register
     logic [ 1:0] dispsel;    // Select data to be supplied on dispout 0-PC, 1-MQ, 2-Memory, 3-AC   
     logic        run    ;    // 0 - stop execution 1 - run program 
     logic        loadpc ;    // Load PC from switch register if CPU stopped
     logic        loadac ;    // Load AC from switch register if CPU stopped
     logic        step   ;    // Execute an instruction if CPU stopped
     logic        deposit;    // Store switch register into memory specified by PC,increment the PC                          
     logic [11:0] dispout;    // data to 7-segment display      
     logic        linkout;    // link to 7-segment display
     logic        halt   ;    // halt instruction  
     
     modport master (input  swreg   , 
                     input  dispsel ,
                     input  run     ,
                     input  loadpc  ,
                     input  loadac  ,
                     input  step    ,
                     input  deposit ,
                     output dispout ,
                     output linkout ,
                     output halt); 
                     
     modport slave  (output swreg   , 
                     output dispsel ,
                     output run     ,
                     output loadpc  ,
                     output loadac  ,
                     output step    ,
                     output deposit ,
                     input  dispout ,
                     input  linkout ,
                     input  halt); 
endinterface

interface iot_pins;
     logic        skip_flag  ;     // skip next instruction
     logic        clearacc   ;     // clear AC in clock period 2 if bit 1 of IR set.   
     logic [ 7:0] datain     ;     // data to OR into AC in clock period 3
     logic        bit1_cp2   ;     // bit 1 of IR set and clock period 2
     logic        bit2_cp3   ;     // bit 2 of IR set and clock period 3
     logic [ 2:0] io_address ;     // IO address (bits 5 to 3 of instruction
     logic [ 7:0] dataout    ;     // lower 8 bits of AC
     
     modport master (input  skip_flag,       
                     input  clearacc,        
                     input  datain,
                     output bit1_cp2,  
                     output bit2_cp3,  
                     output io_address,
                     output dataout); 

     modport slave  (output skip_flag,       
                     output clearacc,        
                     output datain,
                     input  bit1_cp2,  
                     input  bit2_cp3,  
                     input  io_address,
                     input  dataout); 
endinterface

interface memory_pins;
     logic [11:0] read_data    ;   // data read from RAM
     logic        mem_finished ;   // High for 1 clock cycle when memory cycle is finished.                    
     logic [11:0] address      ;   // memory address
     logic [11:0] write_data   ;   // data to write
     logic        write_enable ;   // 1 - write write_data to address on next active clock edge.
     logic        read_enable  ;   // 1 - start read of RAM at address on next active clock edge  
     
     modport master (input  read_data,
                     input  mem_finished,
                     output address,      
                     output write_data,  
                     output write_enable,
                     output read_enable); 
                     
     modport slave  (output read_data,
                     output mem_finished,
                     input  address,      
                     input  write_data,  
                     input  write_enable,
                     input  read_enable); 
endinterface

interface controller_pins     ;
     logic skip               ;         // skip instruction is apporopriate	
     logic ea_reg_8_to_15     ;         // when in auto-incrementing memory locations 
     logic micro_g1           ;         // when in group 1 microcoded
     logic micro_g2           ;         // when in group 2 microcoded
     logic micro_g3           ;         // when in group 3 micrododed
     logic srchange           ;         // when a change in the switch register is detected
     logic eae_fin            ;         // when EAE multiply or divide is complete
     logic eae_start          ;         // when to start multiply or divide module
     AC_ctrl_t AC_ctrl        ;         // mux selector for accumulator
     LK_ctrl_t LK_ctrl        ;         // mux selector for link bit
     MQ_ctrl_t MQ_ctrl        ;         // mux selector for mq register
     PC_ctrl_t PC_ctrl        ;         // mux selector for program counter
     IR_ctrl_t IR_ctrl        ;         // mux selector for instuction register
     EA_ctrl_t EA_ctrl        ;         // mux selector for effective address register
     MB_ctrl_t MB_ctrl        ;         // mux selector for memory buffer
     WD_ctrl_t WD_ctrl        ;         // mux selector for write data 
     AD_ctrl_t AD_ctrl        ;         // mux selector for mem address
     DO_ctrl_t DO_ctrl        ;         // mux selector for display out to front panel
     DT_ctrl_t DT_ctrl        ;         // mux selector for data out to IOT distributor
     PDP8_Registers_t curr_reg;         // all current register values
     
     modport master (input  eae_start      ,
                     input  AC_ctrl        ,
                     input  LK_ctrl        ,
                     input  MQ_ctrl        ,
                     input  PC_ctrl        ,
                     input  IR_ctrl        ,
                     input  EA_ctrl        ,
                     input  MB_ctrl        ,
                     input  WD_ctrl        ,
                     input  AD_ctrl        ,
                     input  DO_ctrl        ,
                     input  DT_ctrl        ,
                     output skip           ,
                     output ea_reg_8_to_15 ,
                     output micro_g1       ,
                     output micro_g2       ,
                     output micro_g3       ,
                     output srchange       ,
                     output eae_fin        ,
                     output curr_reg); 
                     
     modport slave  (output eae_start      ,
                     output AC_ctrl        ,
                     output LK_ctrl        ,
                     output MQ_ctrl        ,
                     output PC_ctrl        ,
                     output IR_ctrl        ,
                     output EA_ctrl        ,
                     output MB_ctrl        ,
                     output WD_ctrl        ,
                     output AD_ctrl        ,
                     output DO_ctrl        ,
                     output DT_ctrl        ,
                     input  skip           ,
                     input  ea_reg_8_to_15 ,
                     input  micro_g1       ,
                     input  micro_g2       ,
                     input  micro_g3       ,
                     input  srchange       ,
                     input  eae_fin        ,
                     input  curr_reg); 
endinterface

`endif