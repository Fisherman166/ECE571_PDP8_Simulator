// CPU_Definitions.pkg
// Jonathan Waldrip

`ifndef CPU_DEF_PKG
`define CPU_DEF_PKG

package CPU_Definitions;

     // Registers
     typedef struct packed {
          logic [11:0] ac;         // accumulator
          logic        lk;         // link bit                   
          logic [11:0] ir;         // instruction register
          logic [11:0] mq;         // mq register }
          logic [11:0] pc;         // program counter
          logic [11:0] mb;         // register to store values from memory 
          logic [11:0] ea;         // effective address register
     } PDP8_Registers_t;
     
     // AC control signal
     typedef enum logic [3:0] {
          AC_SWREG = 0,            // load switch register 
          AC_AND      ,            // AND instruction
          AC_TAD      ,            // TAD instruction
          AC_CLEAR    ,            // Clear 
          AC_MICRO    ,            // Group 1 Microcoded Instruction
          AC_OR_SR    ,            // OR switch register into AC
          AC_OR_MQ    ,            // OR MQ into AC
          AC_OR_DI    ,            // OR datain from IOT with AC 
          AC_LD_MQ    ,            // Load MQ register (for swap) 
          AC_MUL      ,            // Result from EAE for multiply 
          AC_DVI      ,            // Result from EAE for divide
          AC_NC                    // No change
                              } AC_ctrl_t;
     
     // Link control signal
     typedef enum logic [2:0] {
          LK_TAD   = 0,            // TAD instruction
          LK_MICRO    ,            // Group 1 Microcoded Instruction
          LK_MUL      ,            // Clear for multiply 
          LK_DVI      ,            // Result from EAE for divide
          LK_ZERO     ,            // Zero out link bit
          LK_NC                    // No change
                              } LK_ctrl_t;
     
     // MQ control signal
     typedef enum logic [2:0] {
          MQ_AC    = 0,            // for MQ/AC swap operation
          MQ_MUL      ,            // for multiplication
          MQ_DVI      ,            // for division
          MQ_ZERO     ,            // Zero out MQ
          MQ_NC                    // No change
                              } MQ_ctrl_t;
     
     // PC control signal
     typedef enum logic [2:0] {
          PC_P1   = 0,             // Normal PC increment
          PC_EAP1      ,             // Skip
          PC_SR      ,             // Load from front panel
          PC_JMP     ,              
          PC_EA      ,             // Load from effective address
          PC_NC                    // No change
                              } PC_ctrl_t;
     
     // IR control signal
     typedef enum logic [1:0] {
          IR_LD   = 0,             // Load instruction from memory
          IR_MEM_P1  ,             // for auto increment
          IR_NC                    // No change
                              } IR_ctrl_t;
     
     // MB control signal
     typedef enum logic [2:0] {
          MB_INC = 0,              // for ISZ instruction and auto increment
          MB_WD,                   // Write Data
          MB_RD,                   // Store memory read
          MB_ZERO,                 // Zero out
          MB_NC                    // No change
                              } MB_ctrl_t;
     
     // EA control signal
     typedef enum logic [2:0] {
          EA_PGE = 0,              // Change page with upper 5 of PC  
          EA_SMP    ,              // Simple address
          EA_IND    ,              // for indirection
          EA_INC    ,              // for auto-increment indirection
          EA_WD     ,
          EA_ZERO   ,              // Zero out     
          EA_NC                    // No change
                              } EA_ctrl_t;  
                              
     // Memory write data control signal
     typedef enum logic [2:0] {
          WD_MB = 0,               // Contents of memory buffer
          WD_AC    ,               // Contents of accumulator
          WD_EA    ,               // Contents of effective address register
          WD_PC  ,               // Program counter plus 1 
          WD_RDP1  ,
          WD_SR    ,               // Deposit Swith Register to memory     
          WD_NC                    // No change
                              } WD_ctrl_t;                          
     
     // Memory address control signal
     typedef enum logic [2:0] {
          AD_PC = 0,               // Program counter
          AD_PCP1  ,               // Program counter plus 1
          AD_EA    ,               // Contents of effective address register
          AD_SR    ,               // Switch register from front panel     
          AD_NC                    // No change
                              } AD_ctrl_t;  
                              
     // display out control signal
     typedef enum logic [2:0] {
          DO_PC = 0,               // Display program counter
          DO_MQ    ,               // Display MQ register
          DO_MB    ,               // Display memory location contents
          DO_AC    ,               // Display accumulator
          DO_NC                    // No change
                              } DO_ctrl_t; 
                              
     // dataout control signal
     typedef enum logic       {
          DT_AC = 0,               // Output lower 8 bits of AC
          DT_NC                    // No change
                              } DT_ctrl_t;

     // states for controller
     typedef enum logic [5:0] {
          REG_INIT = 0,  // Initial state to initialize registers
          CPU_IDLE,      // Idle State                           
          SR_CHG_1,      // Switch register change while not running
          SR_CHG_2,      
          FETCH_1 ,      // Fetch instruction from memory
          FETCH_2 , 
          FETCH_3 ,                      
          LD_PC_1 ,      // Manual load program counter from switch register                            
          LD_AC_1 ,      // Manual load accumulator from switch register                      
          DEP_1   ,      // Manual deposit to memory               
          DEP_2   ,                         
          CAL_EA_1,      // Effective address calculation                 
          EA_IND_1, 
          EA_IND_2, 
          EA_AUT_1, 
          EA_AUT_2, 
          EA_AUT_3, 
          EA_AUT_4, 
          EA_AUT_5, 
          EA_AUT_6, 
          DECODE  ,      // Decode instruction
          AND_1   ,      // AND Instruction  
          AND_2   ,
          AND_3   ,     
          TAD_1   ,      // TAD Instruction
          TAD_2   ,
          TAD_3   ,     
          ISZ_1   ,      // ISZ Instruction
          ISZ_2   ,
          ISZ_3   ,
          ISZ_4   ,
          ISZ_5   ,
          ISZ_6   ,
          DCA_1   ,      // DCA Instruction     
          DCA_2   ,
          DCA_3   ,
          JMS_1   ,      // JMS Instruction    
          JMS_2   ,    
          JMS_3   ,
          JMP_1   ,
          IOT_1   ,      // IOT Instruction       
          IOT_2   ,
          IOT_3   ,   
          IOT_4   ,
          IOT_5   ,
          IOT_6   ,
          MIC_1   ,      // Microcoded instructions    
          MIC_2   ,   
          MIC_3   ,
          MIC_4   ,
          MIC_5   ,  
          MIC_6   ,
          MIC_7   , 
          MIC_8   ,
          MIC_9   ,
          HALT
                              } Controller_states_t;
                              

endpackage : CPU_Definitions

import CPU_Definitions::*;

interface main_bus;
     // CPU
     PDP8_Registers_t curr_reg;    // Main PDP8 Registers

     // Front Panel
     logic [11:0] swreg       ;    // Switch register
     logic [ 1:0] dispsel = 0 ;    // Select data to be supplied on dispout 0-PC, 1-MQ, 2-Memory, 3-AC   
     logic        run = 0     ;    // 0 - stop execution 1 - run program 
     logic        loadpc = 0  ;    // Load PC from switch register if CPU stopped
     logic        loadac = 0  ;    // Load AC from switch register if CPU stopped
     logic        step = 0    ;    // Execute an instruction if CPU stopped
     logic        deposit = 0 ;    // Store switch register into memory specified by PC,increment the PC                          
     logic [11:0] dispout     ;    // data to 7-segment display      
     logic        linkout     ;    // link to 7-segment display
     logic        halt        ;    // halt instruction
     
     // IOT distributor
     logic        skip_flag   ;    // skip next instruction
     logic        clearacc    ;    // clear AC in clock period 2 if bit 1 of IR set.   
     logic [ 7:0] datain      ;    // data to OR into AC in clock period 3
     logic        bit1_cp2    ;    // bit 1 of IR set and clock period 2
     logic        bit2_cp3    ;    // bit 2 of IR set and clock period 3
     logic [ 2:0] io_address  ;    // IO address (bits 5 to 3 of instruction
     logic [ 7:0] dataout     ;    // lower 8 bits of AC
     
     // Memory
     logic [11:0] read_data    ;   // data read from RAM
     logic        mem_finished ;   // High for 1 clock cycle when memory cycle is finished.                    
     logic [11:0] address      ;   // memory address
     logic [11:0] write_data   ;   // data to write
     logic        write_enable ;   // 1 - write write_data to address on next active clock edge.
     logic        read_enable  ;   // 1 - start read of RAM at address on next active clock edge
     logic        read_type    ;   // Data read or instruction fetch
     
     // CPU Controller
     logic skip                 ;  // skip instruction if apporopriate	
     logic ea_in_auto           ;  // when in auto-incrementing memory locations 
     logic micro_g1             ;  // when in group 1 microcoded
     logic micro_g2             ;  // when in group 2 microcoded
     logic micro_g3             ;  // when in group 3 micrododed
     logic srchange             ;  // when a change in the switch register is detected
     logic CPU_idle             ;  // High when in idle state
     AC_ctrl_t AC_ctrl = AC_NC  ;  // mux selector for accumulator
     LK_ctrl_t LK_ctrl = LK_NC  ;  // mux selector for link bit
     MQ_ctrl_t MQ_ctrl = MQ_NC  ;  // mux selector for mq register
     PC_ctrl_t PC_ctrl = PC_NC  ;  // mux selector for program counter
     IR_ctrl_t IR_ctrl = IR_NC  ;  // mux selector for instuction register
     EA_ctrl_t EA_ctrl = EA_NC  ;  // mux selector for effective address register
     MB_ctrl_t MB_ctrl = MB_RD  ;  // mux selector for memory buffer
     WD_ctrl_t WD_ctrl = WD_NC  ;  // mux selector for write data 
     AD_ctrl_t AD_ctrl = AD_NC  ;  // mux selector for mem address
     DO_ctrl_t DO_ctrl = DO_NC  ;  // mux selector for display out to front panel
     DT_ctrl_t DT_ctrl = DT_NC  ;  // mux selector for data out to IOT distributor
     
     //EAE
     logic [11:0]     mq_mul    ;  // Value for MQ register after multiply is complete 
     logic [11:0]     ac_mul    ;  // Value for AC register after multiply is complete           
     logic [11:0]     mq_dvi    ;  // Value for MQ register after divide is complete 
     logic [11:0]     ac_dvi    ;  // Value for MQ register after divide is complete 
     logic            link_dvi  ;  // Value for Link register after divide is complete 
     logic            eae_fin   ;  // Signal that multiply and/or divide is complete
     logic            eae_start ;  // Signal to start multiply and/or divide     
     
     
     modport cpu   (// Front Panel
                    input  swreg        , 
                    output dispout      ,
                    output linkout      ,

                    // IOT Distributor     
                    input  datain       ,
                    output dataout      , 
                    
                    // Memory          
                    input  read_data    ,
                    output address      , 
                    output write_data   , 
                    
                    // State Machine (Controller)
                    input  AC_ctrl      ,
                    input  LK_ctrl      ,
                    input  MQ_ctrl      ,
                    input  PC_ctrl      ,
                    input  IR_ctrl      ,
                    input  EA_ctrl      ,
                    input  MB_ctrl      ,
                    input  WD_ctrl      ,
                    input  AD_ctrl      ,
                    input  DO_ctrl      ,
                    input  DT_ctrl      ,
                    output ea_in_auto   ,
                    output srchange     ,
                    output curr_reg     ,
                    output skip         ,
                    output micro_g1     ,
                    output micro_g2     ,
                    output micro_g3     ,
                    
                    // EAE Module 
                    input  mq_mul       , 
                    input  ac_mul       , 
                    input  mq_dvi       , 
                    input  ac_dvi       , 
                    input  link_dvi     );
                    
     modport iot   (output skip_flag    ,       
                    output clearacc     ,        
                    output datain       ,
                    input  bit1_cp2     ,  
                    input  bit2_cp3     ,  
                    input  io_address   ,
                    input  dataout      );
                    
     modport mem   (output read_data    ,
                    output mem_finished ,
                    input  address      ,      
                    input  write_data   ,  
                    input  write_enable ,
                    input  read_enable  ,
                    input  read_type    ); 
                    
     modport fsm   (// CPU
                    output AC_ctrl      ,
                    output LK_ctrl      ,
                    output MQ_ctrl      ,
                    output PC_ctrl      ,
                    output IR_ctrl      ,
                    output EA_ctrl      ,
                    output MB_ctrl      ,
                    output WD_ctrl      ,
                    output AD_ctrl      ,
                    output DO_ctrl      ,
                    output DT_ctrl      ,
                    input  skip         ,
                    input  ea_in_auto   ,
                    input  micro_g1     ,
                    input  micro_g2     ,
                    input  micro_g3     ,
                    input  srchange     ,
                    input  curr_reg     , 
                    
                    // EAE
                    output eae_start    ,
                    input  eae_fin      ,
                    
                    // Front Panel
                    input  dispsel      ,
                    input  run          ,
                    input  loadpc       ,
                    input  loadac       ,
                    input  step         ,
                    input  deposit      ,
                    output halt         ,
                    output CPU_idle     ,
                    
                    // IOT distributor
                    input  skip_flag    ,       
                    input  clearacc     ,        
                    output bit1_cp2     ,  
                    output bit2_cp3     ,  
                    output io_address   ,
                    
                    // Memory
                    input  mem_finished ,
                    output write_enable ,
                    output read_enable  ,
                    output read_type    );                    

     modport eae   (output mq_mul       ,
                    output ac_mul       ,
                    output mq_dvi       ,      
                    output ac_dvi       ,
                    output link_dvi     ,      
                    output eae_fin      ,
                    input  eae_start    ,
                    input  curr_reg     );               

     modport fp    (output swreg        , 
                    output dispsel      ,
                    output run          ,
                    output loadpc       ,
                    output loadac       ,
                    output step         ,
                    output deposit      ,
                    input  dispout      ,
                    input  linkout      ,
                    input  halt         ,
                    input  CPU_idle     );               
                    
endinterface

`endif

